#!/usr/bin/env python

'''
Created on 2019/04/27
@author: Naoto Hori
'''

import sys
import os.path
import copy
from cafysis.file_io.pdb import PdbFile
from cafysis.mtx_coord_transform import mtx_crd_transform

'''
PDB BIOMT format
         1         2         3         4         5         6         7
1234567890123456789012345678901234567890123456789012345678901234567890
REMARK 350  
REMARK 350 GENERATING THE BIOMOLECULE
REMARK 350 COORDINATES FOR A COMPLETE MULTIMER REPRESENTING THE KNOWN 
REMARK 350 BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE OF THE
REMARK 350 MOLECULE CAN BE GENERATED BY APPLYING BIOMT TRANSFORMATIONS
REMARK 350 GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC AND 
REMARK 350 CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN. 
REMARK 350
REMARK 350 BIOMOLECULE: ?
REMARK 350 APPLY THE FOLLOWING TO CHAINS: ?, ?...
REMARK 350   BIOMT1   N  N.NNNNNN  N.NNNNNN  N.NNNNNN        N.NNNNN
REMARK 350   BIOMT2   N  N.NNNNNN  N.NNNNNN  N.NNNNNN        N.NNNNN
REMARK 350   BIOMT3   N  N.NNNNNN  N.NNNNNN  N.NNNNNN        N.NNNNN 
'''

assembly_units = []
matrices = {}

row_pre = 0
for l in open(sys.argv[1]):
    if l.find('REMARK 350   BIOMT') != -1:
        #print (l)
        idx_biomt = l.find('BIOMT')
        #print (idx_biomt)

        lsp = l.split()
        # 0 REMARK
        # 1 350
        # 2 BIOMTx 
        # 3 N 

        row = int(lsp[2][5:])
        #print ('row', row)

        if row != row_pre + 1:
            print ('Error row %i is expected but %i loaded' % (row_pre+1, row))
            sys.exit(2)

        mtx_id = int(lsp[3])
        #print ('id', mtx_id)

        if row == 1:
            mtx = mtx_crd_transform()

        mtx.mtx[row-1, 0] = float(lsp[4])
        mtx.mtx[row-1, 1] = float(lsp[5])
        mtx.mtx[row-1, 2] = float(lsp[6])
        mtx.mtx[row-1, 3] = float(lsp[7])

        if row == 3:
            matrices[mtx_id] = mtx
            assembly_units.append(mtx_id)

        if row == 3:
            row_pre = 0
        else:
            row_pre = row

#TEST
#for mtx_id in assembly_units:
#    print (mtx_id)
#    matrices[mtx_id].show()
#sys.exit(1)

filename_pdb = sys.argv[1]

''' Read inpout PDB '''
pdb = PdbFile(filename_pdb)
pdb.open_to_read()
chains = pdb.read_all()
pdb.close()

_, ext = os.path.splitext(filename_pdb) 
filename_base = os.path.basename(filename_pdb)[:-len(ext)]

''' Rotate and output each assembly unit '''
for mtx_id in assembly_units:

    newchains = copy.deepcopy(chains)

    for c in newchains:
        for r in c.residues:
            for a in r.atoms:
                #print ('###')
                #print (a.xyz.x, a.xyz.y, a.xyz.z)
                a.xyz.put_as_list( matrices[mtx_id].do_to_1darray(a.xyz.get_as_ndarray()) )
                #print (a.xyz.x, a.xyz.y, a.xyz.z)
                
    outpdb = PdbFile('%s_%s%s' % (filename_base, mtx_id, ext))
    outpdb.open_to_write()
    outpdb.write_all(newchains)
    outpdb.close()





